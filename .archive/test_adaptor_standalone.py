#!/usr/bin/env python3
"""
Test Suite::Noodle - test_adaptor_standalone.py
Copyright Â© 2025 Michael van Erp. All rights reserved.

This file is part of the NoodleCore project.
Licensed under the MIT License - see LICENSE file for details.

Unauthorized copying, distribution, or modification is prohibited.
"""

"""
Minimal test to verify PythonRuntimeAdapter instrumentation without complex imports issues.
"""
import os
import sys
import tempfile
from pathlib import Path

# Add noodle-core/src to Python path (simple import hack)
sys.path.insert(0, r"C:\Users\micha\Noodle\noodle-core\src")

# Import the trace format
from migration.source_harness.trace_format import Trace, TraceEvent, CallFrame, IOLog

# Create a dummy adapter without the complex import structure
class SimpleTestAdapter:
    def __init__(self):
        self.config = type('Config', (), {
            'enable_io_tracing': True,
            'enable_call_tracing': True
        })()
        self.trace = Trace(
            language="python",
            command=["python", "test.py"],
            working_dir="."
        )
        
    def generate_hook_script(self, script_path: str) -> str:
        """Generate hook script with proper boolean injection."""
        trace_id = self.trace.trace_id
        script_dir = os.path.dirname(script_path)
        
        # Safely encode values using json.dumps for proper quoting
        import json
        trace_id_str = json.dumps(trace_id)
        script_path_str = json.dumps(script_path)
        script_dir_str = json.dumps(script_dir)
        
        # Template for the hook script - MUST USE Capital True/False
        template = '''#!/usr/bin/env python3
# Python Runtime Adapter Hook Script
# Generated by PythonRuntimeAdapter.observe()

import sys
import os
import time
import json
import threading
from pathlib import Path

# Prepare environment - values injected via replace()
_SCRIPT_PATH = @SCRIPT_PATH
_SCRIPT_DIR = @SCRIPT_DIR
_TRACE_ID = @TRACE_ID

# Global state
_TRACE = {
    "trace_id": @TRACE_ID,
    "language": "python",
    "script_path": @SCRIPT_PATH,
    "start_time": time.time(),
    "events": [],
    "call_graph": [],
    "io_log": [],
    "exit_code": 0
}
_LOCK = threading.Lock()
_ORIGINAL_OPEN = open

# Hook function definitions
def hook_open(file, mode='r', *args, **kwargs):
    global _IO_COUNT
    with _LOCK:
        op = {
            "operation": "open",
            "path": str(file),
            "mode": mode,
            "timestamp": time.time(),
            "thread": threading.get_ident()
        }
        _TRACE["io_log"].append(op)
    return _ORIGINAL_OPEN(file, mode, *args, **kwargs)

def hook_trace(frame, event, arg):
    if event == "call":
        with _LOCK:
            call = {
                "name": frame.f_code.co_name,
                "module": frame.f_globals.get("__name__", ""),
                "filename": frame.f_code.co_filename,
                "lineno": frame.f_lineno,
                "timestamp": time.time(),
                "thread": threading.get_ident()
            }
            _TRACE["call_graph"].append(call)
    return hook_trace
    
def finalize():
    _TRACE["end_time"] = time.time()
    _TRACE["duration"] = _TRACE["end_time"] - _TRACE["start_time"]
    
    print(f"")
    print(f"=== Trace ===")
    print(f"Duration: {_TRACE['duration']:.3f}s")
    print(f"Calls: {len(_TRACE['call_graph'])}")
    print(f"IO: {len(_TRACE['io_log'])}")
    print(f"Trace ID: {_TRACE_ID}")
    sys.exit(0)

# Apply instrumentation if enabled
if @IO_TRACING:
    import builtins
    builtins.open = hook_open
    print(f"Instrumentation: I/O tracing enabled")
    
if @CALL_TRACING:
    sys.settrace(hook_trace)
    print(f"Instrumentation: Call tracing enabled")

import atexit
atexit.register(finalize)

print(f"Starting script execution")
# Execute script
sys.argv = ["python", _SCRIPT_PATH] + sys.argv[1:]
exec(open(_SCRIPT_PATH).read(), {"__file__": _SCRIPT_PATH, "__name__": "__main__"})
'''
        
        # Replace placeholders with properly quoted values - USE str() NOT .lower()
        hook_content = template.replace("@SCRIPT_PATH", script_path_str)
        hook_content = hook_content.replace("@SCRIPT_DIR", script_dir_str)
        hook_content = hook_content.replace("@TRACE_ID", trace_id_str)
        hook_content = hook_content.replace("@IO_TRACING", str(self.config.enable_io_tracing))
        hook_content = hook_content.replace("@CALL_TRACING", str(self.config.enable_call_tracing))
        
        return hook_content
        
# Test it
adapter = SimpleTestAdapter()

# Use our simple test script
script_path = r"C:\Users\micha\Noodle\simple_file_processor_fixed.py"
input_path = r"C:\Users\micha\Noodle\sample_input.csv"
output_path = r"C:\Users\micha\Noodle\output.csv"

# Create sample input if needed
if not os.path.exists(input_path):
    with open(input_path, 'w', newline='') as f:
        f.write('col1,col2\nhello,world\n')
    print(f"Created sample input at {input_path}")

# Generate hook script
hook_script = adapter.generate_hook_script(script_path)

# Write hook to temp file and execute
with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
    f.write(hook_script)
    hook_file = f.name

try:
    print(f"Running hooked script: {script_path}")
    import subprocess
    result = subprocess.run(
        [sys.executable, hook_file, input_path, output_path],
        capture_output=True,
        text=True,
        cwd=os.path.dirname(script_path)
    )
    
    print("STDOUT:")
    print(result.stdout)
    if result.stderr:
        print("\nSTDERR:")
        print(result.stderr)
    print(f"\nExit code: {result.returncode}")
    
    # Check if output was created (verify script actually runs)
    if os.path.exists(output_path):
        print(f"\nOutput file created successfully!")
        with open(output_path, 'r') as f:
            print(f"Output content:\n{f.read()}")
    else:
        print(f"\nWARNING: Output file not created - script may have failed")
    
    # Save trace to json file for golden test generation
    if os.path.exists(os.path.join(os.path.dirname(script_path), f"{adapter.trace.trace_id}.json")):
        import shutil
        trace_file = os.path.join(os.path.dirname(script_path), f"{adapter.trace.trace_id}.json")
        dest = os.path.join(os.path.dirname(script_path), "test_trace_captured.json")
        shutil.copy(trace_file, dest)
        print(f"\nTrace saved to: {dest}")
        
finally:
    try:
        os.unlink(hook_file)
    except:
        pass


