/**
 * Mock NoodleCore backend services for testing
 */

export interface AIResponse {
    success: boolean;
    result?: string;
    error?: string;
    data?: any;
}

export interface NoodleCoreConfig {
    backendUrl: string;
    apiKey?: string;
    model: string;
    maxTokens: number;
}

export interface CompilationResult {
    success: boolean;
    output?: string;
    errors?: string[];
    warnings?: string[];
}

export interface RuntimeResult {
    success: boolean;
    output?: string;
    exitCode?: number;
    executionTime?: number;
}

export interface DebugSession {
    id: string;
    state: 'running' | 'stopped' | 'paused';
    breakpoints: any[];
    variables: Map<string, any>;
}

export interface ProjectTemplate {
    name: string;
    description: string;
    files: { [path: string]: string };
    dependencies: { [name: string]: string };
    scripts: { [name: string]: string };
}

/**
 * Mock NoodleCore AI Service
 */
export class MockNoodleCoreAIService {
    private responses: Map<string, AIResponse> = new Map();
    private defaultResponses: Map<string, AIResponse> = new Map();

    constructor() {
        this.setupDefaultResponses();
    }

    private setupDefaultResponses(): void {
        // Default AI responses for testing
        this.defaultResponses.set('analyze', {
            success: true,
            result: 'Code analysis completed. Found 0 issues.'
        });

        this.defaultResponses.set('refactor', {
            success: true,
            result: `// Refactored code
func optimizedFunction() {
    // Optimized implementation
    return result;
}`
        });

        this.defaultResponses.set('explain', {
            success: true,
            result: 'This function implements a sorting algorithm with O(n log n) complexity.'
        });

        this.defaultResponses.set('generate', {
            success: true,
            result: `// Generated code
func generatedFunction() {
    // Auto-generated implementation
    return autoGeneratedResult;
}`
        });

        this.defaultResponses.set('fix', {
            success: true,
            result: `// Fixed code
func fixedFunction() {
    // Fixed implementation with error handling
    return fixedResult;
}`
        });

        this.defaultResponses.set('optimize', {
            success: true,
            result: `// Optimized code
func optimizedFunction() {
    // Performance optimizations applied
    return optimizedResult;
}`
        });

        this.defaultResponses.set('review', {
            success: true,
            result: 'Code review completed. Code quality score: 8/10.'
        });
    }

    public async analyze(code: string): Promise<AIResponse> {
        const response = this.responses.get('analyze') || this.defaultResponses.get('analyze');
        return Promise.resolve(response);
    }

    public async refactor(code: string, type: string): Promise<AIResponse> {
        const response = this.responses.get('refactor') || this.defaultResponses.get('refactor');
        return Promise.resolve(response);
    }

    public async explain(code: string): Promise<AIResponse> {
        const response = this.responses.get('explain') || this.defaultResponses.get('explain');
        return Promise.resolve(response);
    }

    public async generate(prompt: string): Promise<AIResponse> {
        const response = this.responses.get('generate') || this.defaultResponses.get('generate');
        return Promise.resolve(response);
    }

    public async fix(code: string): Promise<AIResponse> {
        const response = this.responses.get('fix') || this.defaultResponses.get('fix');
        return Promise.resolve(response);
    }

    public async optimize(code: string): Promise<AIResponse> {
        const response = this.responses.get('optimize') || this.defaultResponses.get('optimize');
        return Promise.resolve(response);
    }

    public async review(code: string): Promise<AIResponse> {
        const response = this.responses.get('review') || this.defaultResponses.get('review');
        return Promise.resolve(response);
    }

    public setResponse(action: string, response: AIResponse): void {
        this.responses.set(action, response);
    }

    public reset(): void {
        this.responses.clear();
    }
}

/**
 * Mock NoodleCore Compiler Service
 */
export class MockNoodleCoreCompiler {
    private compilationHistory: CompilationResult[] = [];

    public async compile(code: string, options?: any): Promise<CompilationResult> {
        // Simulate compilation process
        const startTime = Date.now();

        // Simulate compilation delay
        await new Promise(resolve => setTimeout(resolve, 100));

        const endTime = Date.now();
        const compilationTime = endTime - startTime;

        // Check for common syntax errors
        const errors = this.checkSyntaxErrors(code);
        const warnings = this.checkWarnings(code);

        const result: CompilationResult = {
            success: errors.length === 0,
            output: errors.length === 0 ? 'Compilation successful' : 'Compilation failed',
            errors,
            warnings
        };

        this.compilationHistory.push(result);
        return Promise.resolve(result);
    }

    private checkSyntaxErrors(code: string): string[] {
        const errors: string[] = [];

        // Check for unclosed braces
        const openBraces = (code.match(/{/g) || []).length;
        const closeBraces = (code.match(/}/g) || []).length;
        if (openBraces !== closeBraces) {
            errors.push('Unmatched braces');
        }

        // Check for missing semicolons
        const lines = code.split('\n');
        lines.forEach((line, index) => {
            const trimmed = line.trim();
            if (trimmed && !trimmed.endsWith(';') && !trimmed.endsWith('{') && !trimmed.endsWith('}')) {
                errors.push(`Missing semicolon at line ${index + 1}`);
            }
        });

        return errors;
    }

    private checkWarnings(code: string): string[] {
        const warnings: string[] = [];

        // Check for unused variables
        const variables = code.match(/(?:let|const|var)\s+(\w+)/g) || [];
        const usedVariables = code.match(/\b(\w+)\b/g) || [];

        variables.forEach((variable) => {
            const varName = variable[1];
            const isUsed = usedVariables.some(used => used[1] === varName);
            if (!isUsed) {
                warnings.push(`Unused variable: ${varName}`);
            }
        });

        return warnings;
    }

    public getCompilationHistory(): CompilationResult[] {
        return [...this.compilationHistory];
    }

    public reset(): void {
        this.compilationHistory = [];
    }
}

/**
 * Mock NoodleCore Runtime Service
 */
export class MockNoodleCoreRuntime {
    private executionHistory: RuntimeResult[] = [];

    public async run(code: string, options?: any): Promise<RuntimeResult> {
        const startTime = Date.now();

        // Simulate execution delay
        await new Promise(resolve => setTimeout(resolve, 200));

        const endTime = Date.now();
        const executionTime = endTime - startTime;

        const result: RuntimeResult = {
            success: true,
            output: 'Execution completed successfully',
            exitCode: 0,
            executionTime
        };

        this.executionHistory.push(result);
        return Promise.resolve(result);
    }

    public getExecutionHistory(): RuntimeResult[] {
        return [...this.executionHistory];
    }

    public reset(): void {
        this.executionHistory = [];
    }
}

/**
 * Mock NoodleCore Debug Service
 */
export class MockNoodleCoreDebugger {
    private sessions: Map<string, DebugSession> = new Map();
    private breakpoints: Map<string, any[]> = new Map();

    public async startDebugging(file: string): Promise<DebugSession> {
        const sessionId = this.generateSessionId();
        const session: DebugSession = {
            id: sessionId,
            state: 'running',
            breakpoints: [],
            variables: new Map()
        };

        this.sessions.set(sessionId, session);
        return Promise.resolve(session);
    }

    public async stopDebugging(sessionId: string): Promise<void> {
        const session = this.sessions.get(sessionId);
        if (session) {
            session.state = 'stopped';
        }
    }

    public async setBreakpoint(file: string, line: number, condition?: string): Promise<void> {
        const sessionId = 'default';
        const session = this.sessions.get(sessionId);

        if (session) {
            const breakpoint = { file, line, condition };
            session.breakpoints.push(breakpoint);
            this.breakpoints.set(`${file}:${line}`, breakpoint);
        }
    }

    public async removeBreakpoint(file: string, line: number): Promise<void> {
        const key = `${file}:${line}`;
        this.breakpoints.delete(key);

        // Remove from all sessions
        this.sessions.forEach(session => {
            session.breakpoints = session.breakpoints.filter(bp =>
                !(bp.file === file && bp.line === line)
            );
        });
    }

    public getDebugSession(sessionId: string): DebugSession | undefined {
        return this.sessions.get(sessionId);
    }

    public getAllBreakpoints(): Map<string, any[]> {
        return new Map(this.breakpoints);
    }

    private generateSessionId(): string {
        return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    public reset(): void {
        this.sessions.clear();
        this.breakpoints.clear();
    }
}

/**
 * Mock NoodleCore Project Manager
 */
export class MockNoodleCoreProjectManager {
    private templates: Map<string, ProjectTemplate> = new Map();
    private projects: Map<string, any> = new Map();

    constructor() {
        this.setupDefaultTemplates();
    }

    private setupDefaultTemplates(): void {
        const templates: ProjectTemplate[] = [
            {
                name: 'Basic AI Project',
                description: 'A basic AI project with agent and model',
                files: {
                    'src/main.nc': `// Basic AI Project
func main() {
    println("Hello, NoodleCore AI!");
    
    // Initialize AI agents
    // TODO: Add your AI agents here
    
    // Load models
    // TODO: Add your AI models here
    
    // Setup pipelines
    // TODO: Add your AI pipelines here
}

main();`,
                    'src/agents/default.nc': `// Default Agent
agent DefaultAgent {
    role: "assistant";
    capabilities: ["code_analysis", "debugging"];
    tools: ["editor", "terminal"];
    prompt: "You are a helpful AI assistant.";
}`,
                    'src/models/default.nc': `// Default Model
ai model DefaultModel {
    type: "neural_network";
    layers: [
        { type: "input", size: 784 },
        { type: "hidden", size: 128, activation: "relu" },
        { type: "output", size: 10 }
    ];
    optimizer: "adam";
    loss: "categorical_crossentropy";
}`
                },
                dependencies: {
                    'noodle-core': '^1.0.0'
                },
                scripts: {
                    'build': 'noodle build',
                    'run': 'noodle run',
                    'test': 'noodle test'
                }
            },
            {
                name: 'Data Processing Project',
                description: 'A project focused on data processing and analysis',
                files: {
                    'src/main.nc': `// Data Processing Project
func processData(data: Dataset) {
    // Preprocess the data
    let processedData = preprocess(data);
    
    // Analyze the data
    let analysis = analyze(processedData);
    
    // Return results
    return analysis;
}`,
                    'src/pipelines/data_processing.np': `// Data Processing Pipeline
pipeline DataProcessing {
    input: "raw_data";
    steps: [
        {
            name: "clean",
            type: "data_cleaning",
            config: {
                remove_nulls: true,
                normalize_text: true
            }
        },
        {
            name: "analyze",
            type: "data_analysis",
            config: {
                statistical_analysis: true,
                visualization: true
            }
        }
    ];
    output: "processed_data";
}`
                },
                dependencies: {
                    'noodle-core': '^1.0.0',
                    'noodle-data': '^0.1.0'
                },
                scripts: {
                    'build': 'noodle build',
                    'process': 'noodle run data-processing',
                    'analyze': 'noodle analyze'
                }
            }
        ];

        templates.forEach(template => {
            this.templates.set(template.name, template);
        });
    }

    public async createProject(name: string, template: string): Promise<any> {
        const projectTemplate = this.templates.get(template);
        if (!projectTemplate) {
            throw new Error(`Template not found: ${template}`);
        }

        const project = {
            name,
            template,
            createdAt: new Date(),
            files: projectTemplate.files
        };

        this.projects.set(name, project);
        return Promise.resolve(project);
    }

    public getTemplate(name: string): ProjectTemplate | undefined {
        return this.templates.get(name);
    }

    public getAllTemplates(): ProjectTemplate[] {
        return Array.from(this.templates.values());
    }

    public getProject(name: string): any {
        return this.projects.get(name);
    }

    public getAllProjects(): any[] {
        return Array.from(this.projects.values());
    }

    public reset(): void {
        this.projects.clear();
    }
}

/**
 * Mock NoodleCore Configuration Service
 */
export class MockNoodleCoreConfigService {
    private config: NoodleCoreConfig = {
        backendUrl: 'http://localhost:8080',
        model: 'gpt-4',
        maxTokens: 1000
    };

    public getConfig(): NoodleCoreConfig {
        return { ...this.config };
    }

    public updateConfig(updates: Partial<NoodleCoreConfig>): void {
        this.config = { ...this.config, ...updates };
    }

    public reset(): void {
        this.config = {
            backendUrl: 'http://localhost:8080',
            model: 'gpt-4',
            maxTokens: 1000
        };
    }
}

/**
 * Mock NoodleCore Service Factory
 */
export class MockNoodleCoreServiceFactory {
    private static aiService: MockNoodleCoreAIService;
    private static compilerService: MockNoodleCoreCompiler;
    private static runtimeService: MockNoodleCoreRuntime;
    private static debuggerService: MockNoodleCoreDebugger;
    private static projectManager: MockNoodleCoreProjectManager;
    private static configService: MockNoodleCoreConfigService;

    public static getAIService(): MockNoodleCoreAIService {
        if (!this.aiService) {
            this.aiService = new MockNoodleCoreAIService();
        }
        return this.aiService;
    }

    public static getCompilerService(): MockNoodleCoreCompiler {
        if (!this.compilerService) {
            this.compilerService = new MockNoodleCoreCompiler();
        }
        return this.compilerService;
    }

    public static getRuntimeService(): MockNoodleCoreRuntime {
        if (!this.runtimeService) {
            this.runtimeService = new MockNoodleCoreRuntime();
        }
        return this.runtimeService;
    }

    public static getDebuggerService(): MockNoodleCoreDebugger {
        if (!this.debuggerService) {
            this.debuggerService = new MockNoodleCoreDebugger();
        }
        return this.debuggerService;
    }

    public static getProjectManager(): MockNoodleCoreProjectManager {
        if (!this.projectManager) {
            this.projectManager = new MockNoodleCoreProjectManager();
        }
        return this.projectManager;
    }

    public static getConfigService(): MockNoodleCoreConfigService {
        if (!this.configService) {
            this.configService = new MockNoodleCoreConfigService();
        }
        return this.configService;
    }

    public static resetAll(): void {
        if (this.aiService) this.aiService.reset();
        if (this.compilerService) this.compilerService.reset();
        if (this.runtimeService) this.runtimeService.reset();
        if (this.debuggerService) this.debuggerService.reset();
        if (this.projectManager) this.projectManager.reset();
        if (this.configService) this.configService.reset();
    }
}