#!/usr/bin/env python3
"""
Noodle Core::Fix Hook - fix_hook.py
Copyright Â© 2025 Michael van Erp. All rights reserved.

This file is part of the NoodleCore project.
Licensed under the MIT License - see LICENSE file for details.

Unauthorized copying, distribution, or modification is prohibited.
"""

"""
Script to fix the _generate_hook_script method in python_adapter.py.
"""
import json
import os
import re
from pathlib import Path

# Path to the file
file_path = Path('noodle-core/src/migration/source_harness/runtime_adapters/python_adapter.py')

# Read the content
content = file_path.read_text(encoding='utf-8')

# Define the new _generate_hook_script method
new_method = '''    def _generate_hook_script(self, script_path: str) -> str:
        """Generate hook script that patches Python builtins."""
        import json
        
        # Determine trace_id to embed
        trace_id = self.trace.trace_id if self.trace else f"trace_{int(time.time())}"
        script_dir = os.path.dirname(script_path)
        
        # Safely encode values for insertion into generated Python code
        trace_id_literal = json.dumps(trace_id)
        script_path_literal = json.dumps(script_path)
        script_dir_literal = json.dumps(script_dir)
        io_tracing_arg = str(self.config.enable_io_tracing).lower()
        call_tracing_arg = str(self.config.enable_call_tracing).lower()
        
        # Template for the generated hook script with placeholders
        template = f'''#!/usr/bin/env python3
# Python Runtime Adapter Hook Script
# Generated by PythonRuntimeAdapter.observe()
 
import sys
import os
import time
import json
import threading
from pathlib import Path
 
# Prepare environment
_SCRIPT_PATH = {script_path_literal}
_SCRIPT_DIR = {script_dir_literal}
_TRACE_ID = {trace_id_literal}
_TRACE_FILE = os.path.join(_SCRIPT_DIR, f"{trace_id_literal}.json")
 
# Global state
_TRACE = None
_IO_COUNT = 0
_CALL_COUNT = 0
_CALL_STACK = []
_LOCK = threading.Lock()
_ORIGINAL_OPEN = open
 
def setup():
    global _TRACE
    _TRACE = {{
        "trace_id": {trace_id_literal},
        "language": "python",
        "script_path": {script_path_literal},
        "start_time": time.time(),
        "events": [],
        "call_graph": [],
        "io_log": [],
        "exit_code": 0
    }}
    
    if {io_tracing_arg}:
        import builtins
        builtins.open = hook_open
    if {call_tracing_arg}:
        sys.settrace(hook_trace)
    import atexit
    atexit.register(finalize)
 
def hook_open(file, mode='r', *args, **kwargs):
    global _IO_COUNT
    with _LOCK:
        op = {{
            "operation": "open",
            "path": str(file),
            "mode": mode,
            "timestamp": time.time(),
            "thread": threading.get_ident()
        }}
        _TRACE["io_log"].append(op)
        _IO_COUNT += 1
    return _ORIGINAL_OPEN(file, mode, *args, **kwargs)
 
def hook_trace(frame, event, arg):
    if event == "call":
        with _LOCK:
            call = {{
                "name": frame.f_code.co_name,
                "module": frame.f_globals.get("__name__", ""),
                "filename": frame.f_code.co_filename,
                "lineno": frame.f_lineno,
                "timestamp": time.time(),
                "thread": threading.get_ident()
            }}
            _TRACE["call_graph"].append(call)
            _CALL_STACK.append(time.time())
    return hook_trace
 
def finalize():
    if not _TRACE:
        return
    _TRACE["end_time"] = time.time()
    _TRACE["duration"] = _TRACE["end_time"] - _TRACE["start_time"]
    if _TRACE_FILE:
        try:
            with open(_TRACE_FILE, "w") as f:
                json.dump(_TRACE, f, indent=2)
        except Exception as e:
            print("[ERROR] Failed to save trace: {}".format(e), file=sys.stderr)
    
    print("\\n=== Trace ===")
    print("Duration: {:.3f}s".format(_TRACE["duration"]))
    print("Calls: {}".format(len(_TRACE["call_graph"])))
    print("IO: {}".format(len(_TRACE["io_log"])))
    print("Trace ID: {}".format(_TRACE["trace_id"]))
    sys.exit(0)
 
# Start instrumentation
setup()
 
# Execute script
sys.argv = ["python", _SCRIPT_PATH] + sys.argv[1:]
exec(open(_SCRIPT_PATH).read(), {"__file__": _SCRIPT_PATH, "__name__": "__main__"})
'''
        
        # Find the start and end of the existing method
        start_marker = "    def _generate_hook_script(self, script_path: str) -> str:"
        end_marker = "    def _start_resource_monitoring(self):"
        start_idx = content.find(start_marker)
        if start_idx == -1:
            raise RuntimeError("_generate_hook_script method not found")
        end_idx = content.find(end_marker, start_idx)
        if end_idx == -1:
            # If not found, go to end of file
            end_idx = len(content)
        # Keep the parts before and after the method
        before = content[:start_idx]
        after = content[end_idx:]
        # Insert the new method
        new_content = before + new_method + after
        # Write back
        file_path.write_text(new_content, encoding='utf-8')
        print("Fixed _generate_hook_script method")
        return


