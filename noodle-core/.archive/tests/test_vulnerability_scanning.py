"""
Test Suite::Noodle Core - test_vulnerability_scanning.py
Copyright Â© 2025 Michael van Erp. All rights reserved.

This file is part of the NoodleCore project.
Licensed under the MIT License - see LICENSE file for details.

Unauthorized copying, distribution, or modification is prohibited.
"""

"""
Test suite for vulnerability scanning system
"""
import os
import json
import unittest
import asyncio
from unittest.mock import Mock, AsyncMock, patch, MagicMock
from datetime import datetime, timedelta

# Import the vulnerability scanning system
from src.noodlecore.security.vulnerability_scanning import (
    VulnerabilityScanningSystem,
    DependencyScanner,
    ContainerScanner,
    InfrastructureScanner,
    ComplianceScanner,
    RiskAssessmentEngine,
    VulnerabilityLifecycleManager,
    VulnerabilityAssessment,
    ScanResult,
    VulnerabilityType,
    RiskLevel,
    VulnerabilityStatus,
    RiskAssessment,
    create_vulnerability_scanning_system
)

# Mock security components
class MockDatabaseManager:
    def __init__(self):
        self.tables = {}
        self.data = {}
    
    def table_exists(self, table_name):
        return table_name in self.tables
    
    def create_table(self, table_name, schema):
        self.tables[table_name] = schema
        self.data[table_name] = []
    
    def insert(self, table_name, data):
        if table_name not in self.data:
            self.data[table_name] = []
        self.data[table_name].append(data)
    
    def select(self, table_name, conditions=None, limit=100, order_by=None):
        results = self.data.get(table_name, [])
        
        if conditions:
            filtered_results = []
            for item in results:
                match = True
                for key, value in conditions.items():
                    if item.get(key) != value:
                        match = False
                        break
                if match:
                    filtered_results.append(item)
            results = filtered_results
        
        if order_by and order_by.endswith('DESC'):
            results = sorted(results, key=lambda x: x.get(order_by.replace(' DESC', ''), ''), reverse=True)
        
        return results[:limit]

class MockAuditLogger:
    def __init__(self):
        self.events = []
    
    async def log_event(self, event_type, level, message, user_id=None, details=None):
        self.events.append({
            'event_type': event_type,
            'level': level,
            'message': message,
            'user_id': user_id,
            'details': details,
            'timestamp': datetime.utcnow()
        })

class MockPenetrationTestingFramework:
    def __init__(self):
        self.test_results = []
    
    async def run_test(self, test_type, target, options=None):
        return {
            'test_id': 'test-123',
            'status': 'completed',
            'vulnerabilities': []
        }

class MockIncidentResponseSystem:
    def __init__(self):
        self.incidents = []
    
    async def create_incident(self, title, description, incident_type, severity, source, technical_details=None, affected_assets=None, tags=None):
        incident = {
            'incident_id': 'incident-123',
            'title': title,
            'description': description,
            'type': incident_type,
            'severity': severity,
            'created_at': datetime.utcnow()
        }
        self.incidents.append(incident)
        return incident

class TestVulnerabilityScanning(unittest.TestCase):
    """Test vulnerability scanning system"""
    
    def setUp(self):
        """Set up test environment"""
        self.test_dir = os.path.join(os.path.dirname(__file__), 'test_vuln_scan_data')
        os.makedirs(self.test_dir, exist_ok=True)
        
        # Create test configuration
        self.test_config = {
            'vulnerability_scanning': {
                'database': {
                    'store_results': True,
                    'table_name': 'test_vulnerability_scan_results'
                },
                'scanners': {
                    'dependency_scanner': {
                        'enabled': True,
                        'scan_interval_hours': 24,
                        'max_scan_duration_minutes': 60
                    },
                    'container_scanner': {
                        'enabled': True,
                        'scan_interval_hours': 24,
                        'max_scan_duration_minutes': 60
                    },
                    'infrastructure_scanner': {
                        'enabled': True,
                        'scan_interval_hours': 24,
                        'max_scan_duration_minutes': 60
                    },
                    'compliance_scanner': {
                        'enabled': True,
                        'scan_interval_hours': 24,
                        'max_scan_duration_minutes': 60
                    }
                },
                'risk_assessment': {
                    'cvss_weight': 0.7,
                    'exposure_weight': 0.3
                },
                'lifecycle_management': {
                    'auto_triage': True,
                    'auto_assign': True
                },
                'integration': {
                    'incident_response': {
                        'auto_create_incidents': True,
                        'severity_mapping': {
                            'critical': 'critical',
                            'high': 'high',
                            'medium': 'medium',
                            'low': 'low'
                        }
                    }
                },
                'auto_scan': {
                    'enabled': False,
                    'schedule': '0 2 * * *',
                    'scan_types': ['dependency', 'container']
                }
            }
        }
        
        # Write test configuration
        config_path = os.path.join(self.test_dir, 'vulnerability_scanning_config.json')
        with open(config_path, 'w') as f:
            json.dump(self.test_config, f)
        
        # Create mock components
        self.mock_db = MockDatabaseManager()
        self.mock_audit_logger = MockAuditLogger()
        self.mock_pen_test = MockPenetrationTestingFramework()
        self.mock_incident_response = MockIncidentResponseSystem()
        
        # Create test vulnerability scanning system
        self.vuln_scanning = VulnerabilityScanningSystem(
            config_path=config_path,
            database_manager=self.mock_db,
            audit_logger=self.mock_audit_logger,
            penetration_testing=self.mock_pen_test,
            incident_response=self.mock_incident_response
        )
    
    def tearDown(self):
        """Clean up test environment"""
        import shutil
        if os.path.exists(self.test_dir):
            shutil.rmtree(self.test_dir)
    
    def test_vulnerability_scanning_initialization(self):
        """Test vulnerability scanning system initialization"""
        self.assertIsNotNone(self.vuln_scanning)
        self.assertIsNotNone(self.vuln_scanning.dependency_scanner)
        self.assertIsNotNone(self.vuln_scanning.container_scanner)
        self.assertIsNotNone(self.vuln_scanning.infrastructure_scanner)
        self.assertIsNotNone(self.vuln_scanning.compliance_scanner)
        self.assertIsNotNone(self.vuln_scanning.risk_assessment_engine)
        self.assertIsNotNone(self.vuln_scanning.lifecycle_manager)
    
    def test_dependency_scanner(self):
        """Test dependency scanner"""
        scanner = DependencyScanner(
            self.test_config['vulnerability_scanning']['scanners']['dependency_scanner'],
            self.mock_audit_logger
        )
        
        # Test with mock dependencies
        with patch('os.walk') as mock_walk:
            mock_walk.return_value = [
                ('/app', ['requirements.txt'], []),
                ('/app', ['package.json'], [])
            ]
            
            with patch('builtins.open') as mock_open:
                # Mock requirements.txt
                mock_open.return_value.__enter__.return_value.read.return_value = """
                requests==2.25.1
                urllib3==1.26.5
                """
                
                # Run the scan
                result = asyncio.run(scanner.scan('/app'))
                
                # Verify results
                self.assertIsInstance(result, list)
    
    def test_container_scanner(self):
        """Test container scanner"""
        scanner = ContainerScanner(
            self.test_config['vulnerability_scanning']['scanners']['container_scanner'],
            self.mock_audit_logger
        )
        
        # Mock subprocess.run
        with patch('subprocess.run') as mock_run:
            mock_run.return_value.stdout = """
            [
                {
                    "Vulnerability": "CVE-2021-1234",
                    "Severity": "HIGH",
                    "Package": "openssl",
                    "Version": "1.1.1",
                    "FixedVersion": "1.1.1k"
                }
            ]
            """
            
            # Run the scan
            result = asyncio.run(scanner.scan('test-image:latest'))
            
            # Verify results
            self.assertIsInstance(result, list)
    
    def test_infrastructure_scanner(self):
        """Test infrastructure scanner"""
        scanner = InfrastructureScanner(
            self.test_config['vulnerability_scanning']['scanners']['infrastructure_scanner'],
            self.mock_audit_logger
        )
        
        # Mock requests.get
        with patch('requests.get') as mock_get:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {
                'services': [
                    {
                        'name': 'ssh',
                        'version': '7.4',
                        'vulnerabilities': ['CVE-2021-1234']
                    }
                ]
            }
            mock_get.return_value = mock_response
            
            # Run the scan
            result = asyncio.run(scanner.scan('192.168.1.1'))
            
            # Verify results
            self.assertIsInstance(result, list)
    
    def test_compliance_scanner(self):
        """Test compliance scanner"""
        scanner = ComplianceScanner(
            self.test_config['vulnerability_scanning']['scanners']['compliance_scanner'],
            self.mock_audit_logger
        )
        
        # Mock requests.get
        with patch('requests.get') as mock_get:
            mock_response = Mock()
            mock_response.status_code = 200
            mock_response.json.return_value = {
                'checks': [
                    {
                        'id': 'cis-1.1.1',
                        'title': 'Ensure filesystem permissions',
                        'status': 'FAIL',
                        'severity': 'MEDIUM'
                    }
                ]
            }
            mock_get.return_value = mock_response
            
            # Run the scan
            result = asyncio.run(scanner.scan('192.168.1.1'))
            
            # Verify results
            self.assertIsInstance(result, list)
    
    def test_risk_assessment_engine(self):
        """Test risk assessment engine"""
        engine = RiskAssessmentEngine(
            self.test_config['vulnerability_scanning']['risk_assessment'],
            self.mock_audit_logger
        )
        
        # Create test vulnerability
        vulnerability = VulnerabilityAssessment(
            id='test-vuln-1',
            type=VulnerabilityType.DEPENDENCY_VULNERABILITY,
            title='Test Vulnerability',
            description='Test vulnerability for assessment',
            severity=RiskLevel.HIGH,
            status=VulnerabilityStatus.NEW,
            discovered_at=datetime.utcnow(),
            source='test',
            target='test-target',
            cvss_score=7.5,
            cve_id='CVE-2021-1234',
            affected_components=['test-component'],
            remediation='Update to latest version',
            references=['https://example.com'],
            metadata={}
        )
        
        # Assess risk
        result = asyncio.run(engine.assess_vulnerability(vulnerability))
        
        # Verify results
        self.assertIsInstance(result, RiskAssessment)
        self.assertGreaterEqual(result.overall_risk_score, 0)
        self.assertLessEqual(result.overall_risk_score, 10)
    
    def test_vulnerability_lifecycle_manager(self):
        """Test vulnerability lifecycle manager"""
        manager = VulnerabilityLifecycleManager(
            self.test_config['vulnerability_scanning']['lifecycle_management'],
            self.mock_audit_logger
        )
        
        # Create test vulnerability
        vulnerability = VulnerabilityAssessment(
            id='test-vuln-1',
            type=VulnerabilityType.DEPENDENCY_VULNERABILITY,
            title='Test Vulnerability',
            description='Test vulnerability for lifecycle management',
            severity=RiskLevel.HIGH,
            status=VulnerabilityStatus.NEW,
            discovered_at=datetime.utcnow(),
            source='test',
            target='test-target',
            cvss_score=7.5,
            cve_id='CVE-2021-1234',
            affected_components=['test-component'],
            remediation='Update to latest version',
            references=['https://example.com'],
            metadata={}
        )
        
        # Triage vulnerability
        result = asyncio.run(manager.triage_vulnerability(vulnerability))
        
        # Verify results
        self.assertIsInstance(result, VulnerabilityAssessment)
        self.assertEqual(result.status, VulnerabilityStatus.TRIAGED)
    
    def test_run_scan(self):
        """Test running a vulnerability scan"""
        # Mock the scanner
        with patch.object(self.vuln_scanning.dependency_scanner, 'scan') as mock_scan:
            mock_scan.return_value = [
                VulnerabilityAssessment(
                    id='test-vuln-1',
                    type=VulnerabilityType.DEPENDENCY_VULNERABILITY,
                    title='Test Vulnerability',
                    description='Test vulnerability',
                    severity=RiskLevel.HIGH,
                    status=VulnerabilityStatus.NEW,
                    discovered_at=datetime.utcnow(),
                    source='test',
                    target='test-target',
                    cvss_score=7.5,
                    cve_id='CVE-2021-1234',
                    affected_components=['test-component'],
                    remediation='Update to latest version',
                    references=['https://example.com'],
                    metadata={}
                )
            ]
            
            # Run the scan
            result = asyncio.run(self.vuln_scanning.run_scan(
                scan_type='dependency',
                target='/app',
                on_demand=True,
                user_id='test-user'
            ))
            
            # Verify results
            self.assertIsInstance(result, ScanResult)
            self.assertEqual(result.scan_type, 'dependency')
            self.assertEqual(result.target, '/app')
            self.assertEqual(result.status, 'completed')
            self.assertEqual(len(result.vulnerabilities), 1)
            self.assertIn('total_vulnerabilities', result.summary)
    
    def test_get_scan_results(self):
        """Test getting scan results"""
        # First add some test data to the database
        vulnerability_data = {
            'id': 'test-vuln-1',
            'scan_id': 'test-scan-1',
            'type': 'dependency_vulnerability',
            'title': 'Test Vulnerability',
            'description': 'Test vulnerability',
            'severity': 'high',
            'status': 'new',
            'discovered_at': datetime.utcnow().isoformat(),
            'source': 'test',
            'target': 'test-target',
            'cvss_score': 7.5,
            'cve_id': 'CVE-2021-1234',
            'affected_components': json.dumps(['test-component']),
            'remediation': 'Update to latest version',
            'references': json.dumps(['https://example.com']),
            'metadata': json.dumps({}),
            'assigned_to': None,
            'due_date': None,
            'verified_at': None,
            'request_id': None
        }
        
        self.mock_db.insert('test_vulnerability_scan_results', vulnerability_data)
        
        # Get scan results
        results = asyncio.run(self.vuln_scanning.get_scan_results(
            scan_id='test-scan-1'
        ))
        
        # Verify results
        self.assertEqual(len(results), 1)
        self.assertEqual(results[0].id, 'test-vuln-1')
        self.assertEqual(results[0].scan_id, 'test-scan-1')
    
    def test_generate_report(self):
        """Test generating vulnerability scan report"""
        # First add some test data to the database
        vulnerability_data = {
            'id': 'test-vuln-1',
            'scan_id': 'test-scan-1',
            'type': 'dependency_vulnerability',
            'title': 'Test Vulnerability',
            'description': 'Test vulnerability',
            'severity': 'high',
            'status': 'new',
            'discovered_at': datetime.utcnow().isoformat(),
            'source': 'test',
            'target': 'test-target',
            'cvss_score': 7.5,
            'cve_id': 'CVE-2021-1234',
            'affected_components': json.dumps(['test-component']),
            'remediation': 'Update to latest version',
            'references': json.dumps(['https://example.com']),
            'metadata': json.dumps({}),
            'assigned_to': None,
            'due_date': None,
            'verified_at': None,
            'request_id': None
        }
        
        self.mock_db.insert('test_vulnerability_scan_results', vulnerability_data)
        
        # Generate JSON report
        json_report = asyncio.run(self.vuln_scanning.generate_report(
            scan_id='test-scan-1',
            output_format='json'
        ))
        
        # Verify JSON report
        self.assertIsInstance(json.loads(json_report), dict)
        self.assertIn('scan_id', json.loads(json_report))
        self.assertIn('vulnerabilities', json.loads(json_report))
        
        # Generate HTML report
        html_report = asyncio.run(self.vuln_scanning.generate_report(
            scan_id='test-scan-1',
            output_format='html'
        ))
        
        # Verify HTML report
        self.assertIn('<html>', html_report)
        self.assertIn('test-scan-1', html_report)
        
        # Generate CSV report
        csv_report = asyncio.run(self.vuln_scanning.generate_report(
            scan_id='test-scan-1',
            output_format='csv'
        ))
        
        # Verify CSV report
        self.assertIn('ID', csv_report)
        self.assertIn('test-vuln-1', csv_report)
    
    def test_create_incidents_for_vulnerabilities(self):
        """Test creating incidents for vulnerabilities"""
        # Create test vulnerabilities
        vulnerabilities = [
            VulnerabilityAssessment(
                id='test-vuln-1',
                type=VulnerabilityType.DEPENDENCY_VULNERABILITY,
                title='Test Vulnerability',
                description='Test vulnerability',
                severity=RiskLevel.CRITICAL,
                status=VulnerabilityStatus.NEW,
                discovered_at=datetime.utcnow(),
                source='test',
                target='test-target',
                cvss_score=9.0,
                cve_id='CVE-2021-1234',
                affected_components=['test-component'],
                remediation='Update to latest version',
                references=['https://example.com'],
                metadata={}
            )
        ]
        
        # Create incidents
        asyncio.run(self.vuln_scanning._create_incidents_for_vulnerabilities(vulnerabilities))
        
        # Verify incidents were created
        self.assertEqual(len(self.mock_incident_response.incidents), 1)
        self.assertEqual(self.mock_incident_response.incidents[0]['title'], 'Vulnerability Detected: Test Vulnerability')
    
    def test_factory_function(self):
        """Test factory function for creating vulnerability scanning system"""
        # Create system using factory function
        system = create_vulnerability_scanning_system(
            config_path=os.path.join(self.test_dir, 'vulnerability_scanning_config.json'),
            database_manager=self.mock_db,
            audit_logger=self.mock_audit_logger,
            penetration_testing=self.mock_pen_test,
            incident_response=self.mock_incident_response
        )
        
        # Verify system was created
        self.assertIsInstance(system, VulnerabilityScanningSystem)
        self.assertIsNotNone(system.dependency_scanner)
        self.assertIsNotNone(system.container_scanner)
        self.assertIsNotNone(system.infrastructure_scanner)
        self.assertIsNotNone(system.compliance_scanner)
        self.assertIsNotNone(system.risk_assessment_engine)
        self.assertIsNotNone(system.lifecycle_manager)

if __name__ == '__main__':
    unittest.main()

