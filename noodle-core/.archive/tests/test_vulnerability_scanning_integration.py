"""
Test Suite::Noodle Core - test_vulnerability_scanning_integration.py
Copyright Â© 2025 Michael van Erp. All rights reserved.

This file is part of the NoodleCore project.
Licensed under the MIT License - see LICENSE file for details.

Unauthorized copying, distribution, or modification is prohibited.
"""

"""
Integration test for vulnerability scanning system with existing NoodleCore security components
"""
import os
import json
import unittest
import asyncio
from datetime import datetime
from unittest.mock import Mock, AsyncMock, patch

# Import NoodleCore security components
from src.noodlecore.security.oauth_jwt_manager import SecurityManager
from src.noodlecore.security.rate_limiter import RateLimitManager
from src.noodlecore.security.input_validator import InputValidator
from src.noodlecore.security.security_headers import SecurityHeadersMiddleware
from src.noodlecore.security.audit_logger import AuditLogger
from src.noodlecore.security.penetration_testing import PenetrationTestingFramework
from src.noodlecore.security.incident_response import IncidentResponseSystem
from src.noodlecore.security.vulnerability_scanning import (
    VulnerabilityScanningSystem,
    create_vulnerability_scanning_system
)

# Mock database manager for testing
class MockDatabaseManager:
    def __init__(self):
        self.tables = {}
        self.data = {}
    
    def table_exists(self, table_name):
        return table_name in self.tables
    
    def create_table(self, table_name, schema):
        self.tables[table_name] = schema
        self.data[table_name] = []
    
    def insert(self, table_name, data):
        if table_name not in self.data:
            self.data[table_name] = []
        self.data[table_name].append(data)
    
    def select(self, table_name, conditions=None, limit=100, order_by=None):
        results = self.data.get(table_name, [])
        
        if conditions:
            filtered_results = []
            for item in results:
                match = True
                for key, value in conditions.items():
                    if item.get(key) != value:
                        match = False
                        break
                if match:
                    filtered_results.append(item)
            results = filtered_results
        
        return results[:limit]

class TestVulnerabilityScanningIntegration(unittest.TestCase):
    """Test vulnerability scanning system integration with existing security components"""
    
    def setUp(self):
        """Set up test environment"""
        self.test_dir = os.path.join(os.path.dirname(__file__), 'test_vuln_scan_integration_data')
        os.makedirs(self.test_dir, exist_ok=True)
        
        # Create test configuration
        self.test_config = {
            'vulnerability_scanning': {
                'database': {
                    'store_results': True,
                    'table_name': 'test_vulnerability_scan_results'
                },
                'scanners': {
                    'dependency_scanner': {
                        'enabled': True,
                        'scan_interval_hours': 24,
                        'max_scan_duration_minutes': 60
                    },
                    'container_scanner': {
                        'enabled': True,
                        'scan_interval_hours': 24,
                        'max_scan_duration_minutes': 60
                    },
                    'infrastructure_scanner': {
                        'enabled': True,
                        'scan_interval_hours': 24,
                        'max_scan_duration_minutes': 60
                    },
                    'compliance_scanner': {
                        'enabled': True,
                        'scan_interval_hours': 24,
                        'max_scan_duration_minutes': 60
                    }
                },
                'risk_assessment': {
                    'cvss_weight': 0.7,
                    'exposure_weight': 0.3
                },
                'lifecycle_management': {
                    'auto_triage': True,
                    'auto_assign': True
                },
                'integration': {
                    'incident_response': {
                        'auto_create_incidents': True,
                        'severity_mapping': {
                            'critical': 'critical',
                            'high': 'high',
                            'medium': 'medium',
                            'low': 'low'
                        }
                    }
                },
                'auto_scan': {
                    'enabled': False,
                    'schedule': '0 2 * * *',
                    'scan_types': ['dependency', 'container']
                }
            }
        }
        
        # Write test configuration
        config_path = os.path.join(self.test_dir, 'vulnerability_scanning_config.json')
        with open(config_path, 'w') as f:
            json.dump(self.test_config, f)
        
        # Create mock database manager
        self.mock_db = MockDatabaseManager()
        
        # Initialize existing security components
        self.security_manager = SecurityManager()
        self.rate_limiter = RateLimitManager()
        self.input_validator = InputValidator()
        self.security_headers = SecurityHeadersMiddleware()
        self.audit_logger = AuditLogger()
        self.penetration_testing = PenetrationTestingFramework()
        self.incident_response = IncidentResponseSystem()
        
        # Create vulnerability scanning system with integration
        self.vuln_scanning = VulnerabilityScanningSystem(
            config_path=config_path,
            database_manager=self.mock_db,
            audit_logger=self.audit_logger,
            penetration_testing=self.penetration_testing,
            incident_response=self.incident_response
        )
    
    def tearDown(self):
        """Clean up test environment"""
        import shutil
        if os.path.exists(self.test_dir):
            shutil.rmtree(self.test_dir)
    
    def test_vulnerability_scanning_initialization(self):
        """Test vulnerability scanning system initialization with existing security components"""
        self.assertIsNotNone(self.vuln_scanning)
        self.assertIsNotNone(self.vuln_scanning.dependency_scanner)
        self.assertIsNotNone(self.vuln_scanning.container_scanner)
        self.assertIsNotNone(self.vuln_scanning.infrastructure_scanner)
        self.assertIsNotNone(self.vuln_scanning.compliance_scanner)
        self.assertIsNotNone(self.vuln_scanning.risk_assessment_engine)
        self.assertIsNotNone(self.vuln_scanning.lifecycle_manager)
        
        # Verify integration with existing components
        self.assertEqual(self.vuln_scanning.audit_logger, self.audit_logger)
        self.assertEqual(self.vuln_scanning.penetration_testing, self.penetration_testing)
        self.assertEqual(self.vuln_scanning.incident_response, self.incident_response)
    
    def test_factory_function_with_existing_components(self):
        """Test factory function with existing security components"""
        # Create system using factory function
        system = create_vulnerability_scanning_system(
            config_path=os.path.join(self.test_dir, 'vulnerability_scanning_config.json'),
            database_manager=self.mock_db,
            audit_logger=self.audit_logger,
            penetration_testing=self.penetration_testing,
            incident_response=self.incident_response
        )
        
        # Verify system was created with existing components
        self.assertIsInstance(system, VulnerabilityScanningSystem)
        self.assertEqual(system.audit_logger, self.audit_logger)
        self.assertEqual(system.penetration_testing, self.penetration_testing)
        self.assertEqual(system.incident_response, self.incident_response)
    
    def test_run_scan_with_audit_logging(self):
        """Test running a scan with audit logging integration"""
        # Mock the scanner to return test vulnerabilities
        with patch.object(self.vuln_scanning.dependency_scanner, 'scan') as mock_scan:
            from src.noodlecore.security.vulnerability_scanning import (
                VulnerabilityAssessment, VulnerabilityType, RiskLevel, VulnerabilityStatus
            )
            
            mock_scan.return_value = [
                VulnerabilityAssessment(
                    id='test-vuln-1',
                    type=VulnerabilityType.DEPENDENCY_VULNERABILITY,
                    title='Test Dependency Vulnerability',
                    description='Test dependency vulnerability',
                    severity=RiskLevel.HIGH,
                    status=VulnerabilityStatus.NEW,
                    discovered_at=datetime.utcnow(),
                    source='test',
                    target='test-target',
                    cvss_score=7.5,
                    cve_id='CVE-2021-1234',
                    affected_components=['test-component'],
                    remediation='Update to latest version',
                    references=['https://example.com'],
                    metadata={}
                )
            ]
            
            # Run the scan
            result = asyncio.run(self.vuln_scanning.run_scan(
                scan_type='dependency',
                target='/app',
                on_demand=True,
                user_id='test-user'
            ))
            
            # Verify scan completed
            self.assertEqual(result.scan_type, 'dependency')
            self.assertEqual(result.target, '/app')
            self.assertEqual(result.status, 'completed')
            self.assertEqual(len(result.vulnerabilities), 1)
            
            # Verify audit logging was called
            self.assertGreater(len(self.audit_logger.events), 0)
            
            # Check for scan start event
            scan_start_event = next(
                (event for event in self.audit_logger.events 
                 if 'Starting vulnerability scan' in event['message']),
                None
            )
            self.assertIsNotNone(scan_start_event)
            self.assertEqual(scan_start_event['user_id'], 'test-user')
            self.assertEqual(scan_start_event['details']['scan_type'], 'dependency')
            
            # Check for scan completion event
            scan_complete_event = next(
                (event for event in self.audit_logger.events 
                 if 'Completed vulnerability scan' in event['message']),
                None
            )
            self.assertIsNotNone(scan_complete_event)
            self.assertEqual(scan_complete_event['user_id'], 'test-user')
    
    def test_incident_response_integration(self):
        """Test incident response integration for critical vulnerabilities"""
        from src.noodlecore.security.vulnerability_scanning import (
            VulnerabilityAssessment, VulnerabilityType, RiskLevel, VulnerabilityStatus
        )
        
        # Create test critical vulnerability
        critical_vulnerability = VulnerabilityAssessment(
            id='test-vuln-critical',
            type=VulnerabilityType.DEPENDENCY_VULNERABILITY,
            title='Critical Dependency Vulnerability',
            description='Critical dependency vulnerability',
            severity=RiskLevel.CRITICAL,
            status=VulnerabilityStatus.NEW,
            discovered_at=datetime.utcnow(),
            source='test',
            target='test-target',
            cvss_score=9.5,
            cve_id='CVE-2021-9999',
            affected_components=['critical-component'],
            remediation='Update immediately',
            references=['https://example.com'],
            metadata={}
        )
        
        # Create incidents for vulnerabilities
        asyncio.run(self.vuln_scanning._create_incidents_for_vulnerabilities([critical_vulnerability]))
        
        # Verify incident was created
        self.assertGreater(len(self.incident_response.incidents), 0)
        incident = self.incident_response.incidents[0]
        self.assertEqual(incident['title'], 'Vulnerability Detected: Critical Dependency Vulnerability')
        self.assertEqual(incident['severity'], 'critical')
    
    def test_database_integration(self):
        """Test database integration for storing scan results"""
        from src.noodlecore.security.vulnerability_scanning import (
            VulnerabilityAssessment, VulnerabilityType, RiskLevel, VulnerabilityStatus
        )
        
        # Create test vulnerability
        vulnerability = VulnerabilityAssessment(
            id='test-vuln-db',
            type=VulnerabilityType.DEPENDENCY_VULNERABILITY,
            title='Database Test Vulnerability',
            description='Test vulnerability for database integration',
            severity=RiskLevel.MEDIUM,
            status=VulnerabilityStatus.NEW,
            discovered_at=datetime.utcnow(),
            source='test',
            target='test-target',
            cvss_score=5.5,
            cve_id='CVE-2021-5555',
            affected_components=['db-component'],
            remediation='Update component',
            references=['https://example.com'],
            metadata={}
        )
        
        # Store scan results
        asyncio.run(self.vuln_scanning._store_scan_results('test-scan-db', [vulnerability]))
        
        # Verify data was stored
        results = self.mock_db.select('test_vulnerability_scan_results')
        self.assertEqual(len(results), 1)
        self.assertEqual(results[0]['id'], 'test-vuln-db')
        self.assertEqual(results[0]['scan_id'], 'test-scan-db')
        self.assertEqual(results[0]['type'], 'dependency_vulnerability')
        self.assertEqual(results[0]['severity'], 'medium')
    
    def test_penetration_testing_integration(self):
        """Test penetration testing framework integration"""
        # Verify penetration testing framework is available
        self.assertIsNotNone(self.vuln_scanning.penetration_testing)
        
        # Test that we can access penetration testing functionality
        self.assertTrue(hasattr(self.penetration_testing, 'run_test'))
        
        # Mock penetration testing to return results
        with patch.object(self.penetration_testing, 'run_test') as mock_test:
            mock_test.return_value = {
                'test_id': 'test-123',
                'status': 'completed',
                'vulnerabilities': []
            }
            
            # Run penetration test
            result = asyncio.run(self.penetration_testing.run_test('sql_injection', 'test-target'))
            
            # Verify test was called
            mock_test.assert_called_once()
            self.assertEqual(result['test_id'], 'test-123')
    
    def test_security_components_compatibility(self):
        """Test compatibility with all security components"""
        # Verify all security components are available and compatible
        self.assertIsNotNone(self.security_manager)
        self.assertIsNotNone(self.rate_limiter)
        self.assertIsNotNone(self.input_validator)
        self.assertIsNotNone(self.security_headers)
        self.assertIsNotNone(self.audit_logger)
        self.assertIsNotNone(self.penetration_testing)
        self.assertIsNotNone(self.incident_response)
        self.assertIsNotNone(self.vuln_scanning)
        
        # Test that components can work together
        # For example, audit logging should work with vulnerability scanning
        self.assertTrue(hasattr(self.audit_logger, 'log_event'))
        self.assertTrue(hasattr(self.vuln_scanning, 'audit_logger'))
        
        # Test that incident response can be triggered by vulnerability scanning
        self.assertTrue(hasattr(self.incident_response, 'create_incident'))
        self.assertTrue(hasattr(self.vuln_scanning, 'incident_response'))
        
        # Test that penetration testing can be used alongside vulnerability scanning
        self.assertTrue(hasattr(self.penetration_testing, 'run_test'))
        self.assertTrue(hasattr(self.vuln_scanning, 'penetration_testing'))

if __name__ == '__main__':
    unittest.main()

